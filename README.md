# algorithm
记录下所做的题，数字均为 力扣 题目题号

## 时间复杂度
程序运行从开始到结束所需要的时间

### 常见时间复杂度：
- O(1): 常数阶 
```
  没有循环语句
 ```
- O(n): 线性阶 
```
  一重循环
 ```
 - O(log n): 对数阶
 ```
 var number = 1
while(number < 100){
    number *= 2
}
// 假设循环次数为 x，2^x = n, x = log2n, 即 O(logn)
// 一般为 n 除以一个常数，经过多少次等于1或者0，比如常见的二分查找法
 ```
 - O(n^2): 平方阶
 ```
// 常见两层循环
for(let i=0;i<n;i++){
    for(let j=i;j<n;j++){
      ......
    }
}
// n+n-1+n-2+n-3+...+3+2+1
// n+n(n-1)/2
// n/2+n^2/2 
// 保留最高阶 n^2*1/2 当n足够大的时候 n/2 忽略不计
// 去掉常数 n^2
 ```
 - O(n^3): 立方阶
 - O(2^n): 指数阶
 - O(n!):  阶乘阶 
 
 *O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) <O(n!)*
 
## 空间复杂度
运行完一个程序所需内存的大小

假设原始数据大小为n，一个算法需要m大小的内存才能运行，那么我们就有一个函数f(n)=m。这个函数去掉常数项和尾数项就是空间复杂度

比如说，如果用冒泡排序对数据排序，如果直接在原始数据上排，那么根本不需要额外的存储空间，而最多只需要定义几个变量，那么复杂度就是1
如果排序产生一个新的数组，不修改原来的数组，那么对于排序n个数据，就需要n个新的存储空间，那么复杂度就是n。

如果需要一个辅助数组，空间复杂度为O(n)
如果需要一个二维的辅助数组，空间复杂度为O(n^2)
对于递归，空间复杂度等于递归深度

## 推算方法
1. 用常数1来取代运行时间中所有加法常数。
2. 修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。

[经典排序](https://github.com/chun1hao/MyBlog/tree/master/algorithm)  
[双指针](https://github.com/chun1hao/algorithm/labels/%E5%8F%8C%E6%8C%87%E9%92%88)  
[查找表](https://github.com/chun1hao/algorithm/labels/%E6%9F%A5%E6%89%BE%E8%A1%A8)
[链表](https://github.com/chun1hao/algorithm/labels/%E9%93%BE%E8%A1%A8)
